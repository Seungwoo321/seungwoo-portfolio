export interface ProjectQA {
  question: string;
  answer: string;
  type: 'technical' | 'business' | 'design';
  code?: string;
}

const projectQAs: Record<string, ProjectQA[]> = {
  'e-torch': [
    {
      question: '데이터 소스 아키텍처가 개발 중에 변경된 이유는 무엇인가요?',
      answer: `초기에는 KOSIS/ECOS 데이터를 별도 DB에 마이그레이션하여 관리하는 구조로 설계했습니다. CLI 도구를 개발하여 데이터 마이그레이션을 자동화했고, Mock API 서버도 구축하여 개발 환경을 구성했습니다. Mock API는 https://etorch-mock-api.vercel.app/ 에서 운영 중이며, GitHub 저장소는 https://github.com/Seungwoo321/etorch-mock-api 에 있습니다. JSON Server 기반으로 RESTful API를 구현했고, 별도 DB 운영을 위한 인프라도 설계했습니다.

하지만 실제 개발 과정에서 몇 가지 문제점을 발견했습니다. DB 운영 비용이 예상보다 높았고, 원본 데이터가 업데이트될 때 동기화가 지연되는 문제가 있었습니다. 또한 새로운 지표를 추가할 때마다 개발자의 수동 작업이 필요했습니다.

AI와 논의 끝에 관리자 페이지를 통해 원본 데이터 소스에 직접 접근하는 방식으로 전환했습니다. 이제 관리자가 필요한 지표의 파라미터를 DB에 저장하면, 실시간으로 원본 API에서 데이터를 페칭합니다. 이를 통해 비용을 절감하고 데이터의 최신성도 보장할 수 있게 되었습니다.`,
      type: 'technical'
    },
    {
      question: '파라미터 관리 방식을 하드코딩에서 DB 관리로 변경한 이유는?',
      answer: `초기에 파일로 하드코딩한 이유는 몇 가지였습니다. KOSIS와 ECOS 각각 파라미터 체계가 달라 복잡했고, 원하는 지표만 선별하여 관리할 필요가 있었습니다. 처음부터 DB를 구축하는 것은 개발 부담이 컸기 때문에 초기 52개 지표로 시작했습니다. KOSIS 14개, ECOS 38개였는데, 자세한 목록은 https://github.com/Seungwoo321/etorch-docs/blob/main/product-spec.md#부록-제공-경제지표-상세-목록 에서 확인할 수 있습니다.

하지만 파일 관리의 문제점이 곧 드러났습니다. 52개 지표로 제한되어 확장이 불가능했고, 새 지표를 추가할 때마다 개발자가 코드를 수정해야 했습니다. 배포 없이는 지표 추가가 불가능했고, 비개발자는 지표 관리를 할 수 없었습니다.

이때 AI 기반 개발의 이점을 발견했습니다. AI와 협업하여 관리자 페이지를 빠르게 구현할 수 있었고, 복잡한 파라미터 체계도 UI로 쉽게 관리할 수 있게 되었습니다. DB 설계와 구현이 예상보다 빨랐습니다.

최종적으로 관리자 페이지와 DB를 결합한 해결책을 채택했습니다. 관리자가 UI를 통해 지표 파라미터를 설정하고, 실시간으로 지표를 추가, 수정, 삭제할 수 있게 되었습니다. 파라미터 템플릿 시스템도 도입했습니다.

결과적으로 52개 제한에서 무제한 확장 가능한 구조로 전환되었고, 개발자 개입 없이 KOSIS/ECOS 수천 개 지표를 즉시 추가할 수 있게 되었습니다. 지표 추가 시간도 개발과 배포에 1-2일 걸리던 것이 관리자 페이지에서 5분으로 단축되었습니다.`,
      type: 'technical',
      code: `// Before: 하드코딩된 파라미터
const INDICATORS = {
  GDP: {
    apiKey: 'KOSIS_API_KEY',
    tableId: 'DT_1Y0001',
    params: { startPeriod: '2020', endPeriod: '2024' }
  }
}

// After: DB 기반 동적 파라미터
const indicator = await db.indicators.findOne({ code: 'GDP' });
const data = await fetchAPI(indicator.source, indicator.params);`
    },
    {
      question: '복잡한 다중 시계열 차트 UI를 어떻게 설계했나요?',
      answer: `서로 다른 단위의 경제 지표를 하나의 차트에 표시하는 UI 플로우 설계 과정을 설명하겠습니다.

2024년 6월 초기 접근 방식은 옵션창에서 지표를 선택하고, 조회 버튼을 누르면 데이터를 가져와서 차트에 표시하는 것이었습니다. 단일 지표는 간단했지만 복수 지표에서 문제가 발생했습니다. GDP는 조 단위, 환율은 천원대, 실업률은 퍼센트인데 이걸 하나의 Y축에 표시할 수는 없었습니다. 각 지표마다 Y축 설정을 사용자가 수동으로 해야 했고, 데이터를 조회한 후에야 스케일 문제를 발견하게 되었습니다.

핵심 문제는 "지표 선택 → 데이터 조회 → Y축 할당"이라는 순서가 잘못되었다는 것이었습니다. 데이터를 먼저 가져온 후 Y축을 정하니 너무 복잡했고, 사용자는 어떤 Y축에 할당될지 예측할 수 없었습니다. 스케일이 다른 데이터가 섞여 차트가 망가지는 문제도 있었습니다.

2025년 5월에 플로우를 재설계했습니다. 먼저 시리즈 슬롯을 최대 5개까지 생성하고, 각 슬롯에서 지표를 검색하도록 모달로 분리했습니다. Y축을 자동으로 제안하되 첫 번째는 left, 두 번째는 right로 하고 사용자가 변경할 수 있게 했습니다. 설정을 완료한 후에 데이터를 조회하고 차트에 시각화하는 순서로 변경했습니다.

SeriesConfiguration 컴포넌트가 혁신의 핵심이었습니다. 데이터 조회 전에 Y축 할당을 완료하고, 시리즈별 독립적 설정으로 명확한 구조를 만들었습니다. 지표 검색과 설정을 분리해 복잡도를 감소시켰고, 실시간 미리보기로 결과를 예측할 수 있게 했습니다.

"설정 먼저, 조회 나중" 패러다임으로 문제를 해결했고, 사용자가 Y축 배치를 완전히 제어할 수 있게 되었습니다. 복잡한 다중 지표도 직관적으로 설정할 수 있게 되었습니다.`,
      type: 'technical'
    },
    {
      question: 'AI와의 협업 방법론은 어떻게 구축했나요?',
      answer: `체계적인 AI 협업을 위해 2개의 개발 가이드라인을 작성하여 프로젝트 전반에 적용했습니다. AI 개발 가이드라인은 https://github.com/Seungwoo321/etorch-docs/blob/main/AI_DEVELOPMENT_GUIDELINES.md 와 https://github.com/Seungwoo321/etorch-docs/blob/main/ROOT_CAUSE_ANALYSIS_GUIDE.md 에서 확인할 수 있습니다.

핵심 협업 원칙은 세 가지입니다. 첫째, Sequential Thinking 접근법을 적용했습니다. 모든 작업을 단계별로 체계적으로 수행하고, 분석, 계획, 실행, 검증 순서를 준수하며, 각 단계별로 명확하게 문서화했습니다.

둘째, 승인 기반 작업 프로세스를 도입했습니다. 코드 변경 전에는 반드시 명시적 승인이 필요하고, 변경 이유와 영향 범위를 설명해야 하며, 무단 수정은 엄격히 금지했습니다.

셋째, 근본 원인 분석(RCA)을 활용했습니다. "코드는 진실이다"라는 원칙하에 가정 없이 증거 기반으로 분석하고, 시각화를 통해 문제를 파악했습니다.

실제 적용 사례를 보면, 개발 중 발생한 모든 이슈를 가이드라인 기반으로 해결했습니다. Sequential Thinking으로 문제를 단계별로 분해했고, 근본 원인 분석으로 정확한 문제 지점을 파악했습니다. 관리자 페이지나 LTTB 같은 AI 제안사항도 검토 후 적용했습니다.

결과적으로 명확한 가이드라인으로 AI와 일관된 협업이 가능했고, 예상치 못한 개선사항을 발견하고 적용할 수 있었습니다. 6개월 동안 막혔던 문제를 2주 만에 해결하는 성과도 있었습니다.`,
      type: 'technical'
    }
  ],

  'penguinjs': [
    {
      question: '왜 JavaScript 학습 플랫폼을 게임으로 만들었나요?',
      answer: `Flexbox Froggy를 즐겁게 플레이한 경험에서 영감을 받았습니다. JavaScript의 추상적 개념들도 게임으로 만들면 재미있겠다는 생각이 들었고, 특히 클로저나 콜스택 같은 개념을 시각적으로 표현해보고 싶었습니다. 개인적으로 게임을 만들어보고 싶다는 호기심도 있었습니다.

게임 방식을 선택한 이유는 명확했습니다. 코드만 보면 지루한데 시각적 피드백이 있으면 재미있고, 스테이지를 클리어하는 성취감이 학습 동기가 됩니다. 틀려도 게임이니까 부담 없이 다시 시도할 수 있고, 자연스럽게 반복하면서 개념이 익숙해집니다.

개발 과정에서 동굴 탐험, 도서관 정리 등 게임 메타포를 설계하고, 펭귄이 보물을 찾아가는 애니메이션을 구현하며, 코드 에디터에서 실제 코딩하면서 게임이 진행되도록 만드는 것이 재미있었습니다.

향후 계획으로는 18개 게임을 기획했는데 현재 2개를 완료했고, 나머지는 점진적으로 구현할 예정입니다. Promise Battle 같은 비동기 게임도 개발 중이며, 각 게임당 15단계씩 총 270개 스테이지를 목표로 하고 있습니다.`,
      type: 'design'
    },
    {
      question: 'Closure Cave 게임의 학습 메커니즘은 어떻게 설계했나요?',
      answer: `클로저 개념을 동굴 탐험 메타포로 구현했습니다. 동굴은 함수 스코프를 나타내고, 보물은 변수를 의미하며 다이아몬드, 에메랄드, 사파이어로 구분됩니다. 펭귄은 실행 컨텍스트를 표현하고, 열쇠는 클로저로 접근 권한을 나타냅니다.

실제로 구현된 15개 스테이지는 난이도별로 구성했습니다. 초급 5단계에서는 기본 함수 스코프, 간단한 클로저, 외부 변수 접근을 다루고, 중급 5단계에서는 카운터 구현, 데이터 보호, 모듈 패턴을 학습합니다. 고급 5단계에서는 메모리 관리, 팩토리 패턴, 이벤트 핸들러 같은 실무 패턴을 다룹니다.

학습을 강화하기 위해 게임 요소로 펭귄 위치, 보물, 장애물, 출구 포털을 배치했고, 성공 조건으로 수집한 보물 수, 생성된 변수, 반환된 함수를 체크합니다. 각 스테이지별로 테스트 케이스가 자동 검증되며, 3단계 점진적 힌트 시스템도 제공합니다.

실제 구현 방식은 코드 에디터에서 JavaScript를 작성하면 eval()과 Function()으로 코드를 실행하고 검증하며, 시각적 피드백과 애니메이션이 연동되도록 했습니다.`,
      type: 'technical',
      code: `// Stage 1 실제 코드: 동굴 입구 - 첫 번째 보물
function openTreasureBox() {
  let treasure = "💎 다이아몬드";
  
  return function() {
    return treasure; // 클로저로 보물 접근
  };
}

const getTreasure = openTreasureBox();
return getTreasure(); // 펭귄이 보물 획득!`
    },
    {
      question: 'CallStack Library 게임은 어떻게 콜스택을 학습시키나요?',
      answer: `콜스택 동작을 6가지 레이아웃 타입으로 단계적으로 학습하도록 설계했습니다.

레이아웃 A는 초급 1-8단계로 기본 콜스택을 다룹니다. 함수 호출 순서를 예측하고, 코드 에디터와 콜스택, 함수 선택기를 통해 단순한 함수 호출과 반환 흐름을 이해합니다.

레이아웃 A+는 중급 9-16단계로 시작과 종료 추적에 중점을 둡니다. LIFO 원칙을 체득하고, 함수 시작과 종료 시점을 파악하며, 중첩 함수와 재귀 패턴을 학습합니다.

레이아웃 E는 고급 17-21단계로 스택 스냅샷을 다룹니다. 실행 단계별 스택 상태를 예측하고, 스냅샷 빌더로 각 시점의 콜스택 상태를 구성하며, 복잡한 재귀와 중첩 호출을 분석합니다.

레이아웃 B는 고급 22단계에서 이벤트 루프를 학습합니다. 콜스택과 마이크로/매크로 태스크 큐를 다루며 Promise, setTimeout 등 비동기 처리를 이해합니다. 레이아웃 C는 고급 23단계로 5개 큐 시스템을 다루고, 레이아웃 D는 고급 24단계에서 6개 큐 시스템을 완전 통합하여 실무 수준의 복잡한 비동기 처리를 학습합니다.

교육적 특징으로는 레이아웃별로 UI 구성과 평가 방식이 다르고, 점진적 난이도 상승으로 자연스러운 학습이 가능하며, 실제 코드 작성과 실행 순서 예측을 병행합니다.`,
      type: 'technical'
    },
    {
      question: '게임 개발하면서 가장 어려웠던 점은 무엇인가요?',
      answer: `기획 없이 시작해서 개발하면서 동시에 설계하는 것이 가장 어려웠습니다.

첫 번째로 디자인 시스템이 부재했습니다. 다크/라이트 테마 구현에서 상당히 애먹었고, 게임별 일관된 UI/UX 가이드라인도 없었습니다. E-Torch와 달리 기획서나 화면 설계 없이 시작한 것이 문제였습니다.

두 번째로 CallStack Library 레이아웃 설계가 혼란스러웠습니다. 6개 레이아웃별로 다른 화면 구성과 기능을 가지고 있었고, 처음 15단계로 시작했다가 24단계로 증가시켰습니다. 특히 레이아웃 B, C, D는 각각 22, 23, 24단계에서 1회만 사용되어 반복 학습이 부족해 학습 효과 저하가 우려됩니다.

세 번째로 개발과 기획이 충돌했습니다. 코드를 작성하면서 동시에 게임을 설계하다 보니, 이미 구현한 부분 때문에 기획 변경이 어려웠고, 전체적인 일관성과 완성도가 부족했습니다.

이 시행착오를 통해 얻은 교훈이 있습니다. 단순한 호기심으로 "이게 될까?"하고 시작했는데, 아무것도 없이 바로 코딩을 시작하니 기획과 디자인이 막히면 개발도 막혔습니다. 체계적인 기획의 중요성을 절감했습니다.

E-Torch는 2주간 문서를 작성한 후 개발해서 순조롭게 진행됐는데, PenguinJS는 기획 없이 바로 개발하니 지속적인 설계 변경과 혼란이 있었습니다. AI 개발은 상상을 현실로 만들어주지만, 구체적인 상상이 없으면 AI도 현실화하기 어렵다는 교훈을 얻었습니다. 명확한 비전과 설계가 있어야 AI가 제대로 도와줄 수 있고, 추상적인 아이디어만으로는 AI와 협업해도 한계가 명확했습니다.

그럼에도 불구하고 기획 없이 시작했지만 결과물의 완성도에는 만족합니다. 아직 버그는 있지만 핵심 게임플레이는 잘 작동하고, 추상적인 JavaScript 개념을 실제 플레이 가능한 게임으로 구현한 것 자체가 성과라고 생각합니다.`,
      type: 'technical'
    }
  ],

  'tailwind-grid-layout': [
    {
      question: 'react-grid-layout이 있는데 왜 새로 만들었나요?',
      answer: `E-Torch 프로젝트에서 react-grid-layout을 사용하며 반복적인 문제가 발생했습니다.

구체적인 문제점:
- resize 시 height = 0
- drag 시 width = 0  
- 위젯 위치가 비정상적으로 이동
- shadcn/ui + Tailwind CSS 조합에서 충돌 추정

처음에는 다양한 설정 조합을 시도하고, CSS 오버라이드를 적용하며, 여러 버전을 테스트해봤지만 모두 근본적인 해결이 불가능했습니다. 포기하는 대신 AI를 활용해 새로 만들기로 결정했고, Claude Code와 MCP CLI를 기반으로 AI 주도 개발을 진행했습니다. 처음부터 만드는 프로젝트였기 때문에 AI에 전면 위임이 가능했고, Tailwind CSS v4와 shadcn/ui 환경에 최적화된 라이브러리를 개발할 수 있었습니다.

결과적으로 react-grid-layout의 100% API 호환성을 유지하면서도 번들 사이즈를 30% 감소시켰고, shadcn/ui 환경에서 안정적으로 동작하며, 100% 테스트 커버리지와 자동 배포 시스템까지 구축했습니다.`,
      type: 'technical'
    },
    {
      question: 'AI와의 역할 분담은 어떻게 했나요?',
      answer: `Claude Code와 MCP CLI를 활용한 완전한 AI 주도 개발을 실험했습니다. 제 역할은 기능 테스트와 요구사항 정리, Vercel에서 GitHub 레포 직접 연동, NPM 배포용 키 등록 같은 민감한 설정 처리에 집중했습니다. Claude는 코드 작성과 리팩토링 등 모든 개발을 전담했고, GitHub Actions 워크플로우 작성, 브랜치 생성과 PR 및 커밋 등 Git 작업, 테스트 코드 생성과 100% 커버리지 달성까지 처리했습니다.

AI 협업을 하면서 몇 가지 중요한 인사이트를 발견했습니다. 복잡도가 올라갈수록 명확한 프롬프트가 중요했고, Claude가 모든 맥락을 기억하지 못해 방향이 이탈할 가능성이 있었습니다. 컨텍스트 압축에도 한계가 있어서 잘못된 작업을 했을 때는 git reset --hard로 복구한 적도 있었습니다. 결국 프롬프트와 내부 규칙으로 방향을 제시하는 것이 핵심이었습니다.

병렬 작업도 실험해봤는데, 터미널 화면을 3-4분할하고 Git 워크트리로 개별 브랜치를 동시에 작업했습니다. 하지만 3개 이상부터는 작업 이력 추적과 지시 관리가 어려워져서, 현실적으로는 1-2개의 병렬 작업이 적절하다는 결론을 내렸습니다. 병렬 진행은 효율보다 피로도가 높아질 수 있었습니다.

처음부터 만드는 프로젝트였기 때문에 AI에 전면 위임이 가능했고, 기존 프로젝트에서는 AI 수정이 부담될 수 있지만 새 프로젝트에서는 매우 효과적이었습니다.`,
      type: 'technical'
    },
    {
      question: '테스트 커버리지 100%인데 버그가 발견되었다고요?',
      answer: `100% 테스트 커버리지를 달성했지만, Storybook 인터랙션 테스트에서 실제 사용 시나리오의 버그들을 추가로 발견했습니다.

발견된 4가지 버그:
1. fix-autosize-dropping-item - 드롭 프리뷰가 항상 표시되는 문제
2. fix-droppable-container-tracking - 외부 드래그 아이템 실시간 추적 불가
3. fix-dropping-item-preview-position - 드롭 프리뷰 위치와 마우스 커서 불일치
4. fix-resize-handle-static-collision - 리사이즈 시 정적 아이템 충돌 감지 미흡

여러 버그를 효율적으로 수정하기 위해 Git 워크트리를 활용하고 있습니다. 각 버그별로 독립된 작업 공간을 만들어 병렬 개발을 진행하고, CLAUDE_HANDOVER.md로 AI와의 작업 인수인계를 체계화했습니다.

단순 유닛 테스트로는 발견하기 어려운 복잡한 상호작용 버그들을 동시에 해결해 나가고 있으며, 최종 테스트를 거친 후 다시 배포될 예정입니다. 이 경험을 통해 100% 테스트 커버리지가 버그 없는 코드를 보장하지는 않으며, 실제 사용 시나리오를 반영한 통합 테스트의 중요성을 다시 한번 확인했습니다.`,
      type: 'technical'
    }
  ],

  'frontend-learning-app': [
    {
      question: '앞으로의 개발 로드맵은 어떻게 되나요?',
      answer: `앞으로의 개발은 우선순위에 따라 네 가지 단계로 진행할 계획입니다. 가장 먼저 콘텐츠 완성에 집중하여 AI 파이프라인을 통해 2,610개 세부 토픽을 생성하고, 각 토픽별로 3단계 난이도의 콘텐츠와 퀴즈 및 연습 문제를 추가할 예정입니다.

두 번째로는 핵심 기능 구현에 착수합니다. WebView와 React Native 간의 양방향 통신을 구현하여 진도 추적 기능을 완성하고, WebView 기반의 퀴즈 렌더링 시스템을 개발할 것입니다.

세 번째 단계에서는 사용성 개선에 초점을 맞춰 영어, 일본어, 중국어 등 다국어 지원과 다크 테마를 구현할 계획입니다. 마지막으로 성취도 배지 시스템, 오프라인 지원을 위한 콘텐츠 번들링, 소셜 공유 기능 같은 선택적 기능들은 낮은 우선순위로 진행할 예정입니다.

콘텐츠 생산과 핵심 학습 기능 완성에 집중하여 실제 사용 가능한 학습 앱으로 발전시키는 것이 현재의 목표입니다.`,
      type: 'business'
    },
    {
      question: '이 프로젝트를 시작하게 된 계기는 무엇인가요?',
      answer: `AI의 우수한 답변을 정적 학습 자료로 체계적으로 보관하고자 이 프로젝트를 시작하게 되었습니다. AI와의 대화는 휘발성이 높아서 좋은 답변을 받아도 나중에 다시 찾기 어렵고, 같은 질문을 반복할 때마다 토큰을 소비한다는 문제가 있었습니다. 특히 "중학생도 이해할 수 있게 설명해줘"처럼 쉬운 설명을 요청했을 때 받은 훌륭한 답변들은 일반적인 자료에서는 찾기 어려운 귀중한 내용들이었습니다.

이러한 문제를 해결하기 위해 모든 학습 콘텐츠를 3단계 난이도로 생성하여 언제든 접근 가능한 개인 지식 라이브러리를 구축하기로 했습니다. 쉬움 단계는 중학생도 이해할 수 있도록 일상적인 비유와 친근한 설명을 사용하고, 일반 단계는 실무자를 위해 적절한 전문 용어와 실용적인 예제를 포함시켰으며, 전문가 단계는 심화 학습을 원하는 사람들을 위해 내부 원리와 성능 최적화까지 다루도록 구성했습니다.

현재 HTML, CSS, JavaScript, React, Next.js 등 10개 주제에 걸쳐 261개 카테고리, 총 2,610개의 세부 토픽을 계획하고 있습니다. MD 파일 기반으로 구축하여 향후 경제, 블록체인, AI 등 다양한 분야로도 확장 가능한 구조를 갖추었습니다. 현재까지 20개 이상의 토픽을 완성했고, AI 콘텐츠 생성 파이프라인 구축과 WebView 통합을 완료한 상태입니다.`,
      type: 'business'
    },
    {
      question: 'React Native와 WebView를 혼합한 이유는?',
      answer: `React Native에서 마크다운 런타임 파싱이 지원되지 않아서, 처음에는 TypeScript 모듈로 콘텐츠를 작성하는 방식을 시도했지만 생산성 문제에 부딪혀 WebView 하이브리드 방식으로 전환했습니다.

첫 번째 해결책으로 마크다운 자료를 TypeScript 모듈로 변환하여 작성했습니다. 화면에 렌더링되는 내용을 기준으로 섹션을 나누어 여러 개의 TS 파일을 만들었는데, AI로 이 포맷에 맞게 콘텐츠를 생산하는 과정에서 백틱이나 특수문자 이스케이프 문제로 오류가 반복적으로 발생했습니다. AI 활용의 목적은 콘텐츠 품질에 집중하는 것이었는데, 포맷 오류 수정에 시간을 빼앗기는 상황이 계속되었습니다. 또한 콘텐츠를 수정할 때마다 빌드가 필요하다는 점도 매우 비효율적이었습니다.

이를 해결하기 위해 React Native와 WebView의 역할을 명확히 분리한 하이브리드 아키텍처를 설계했습니다. React Native는 네비게이션과 라우팅, 학습 경로 관리, 진도 추적 시스템, 푸시 알림이나 로컬 저장소 같은 네이티브 기능을 담당합니다. WebView에서 실행되는 React 웹앱은 학습 콘텐츠 렌더링, 코드 에디터와 실행 환경, 마크다운 파싱, 인터랙티브 시각화를 처리합니다.

두 시스템은 postMessage를 통한 양방향 통신으로 연결되어 진도 데이터를 동기화하고, 테마 설정을 공유하며, 에러 핸들링도 통합 관리합니다. 이러한 접근으로 콘텐츠 업데이트의 유연성을 확보하고, 웹 기술의 장점을 활용하면서도 빠른 개발 속도와 크로스 플랫폼 일관성을 모두 달성할 수 있었습니다.`,
      type: 'technical'
    }
  ],

  'vue-pivottable': [
    {
      question: 'Vue.js를 처음 학습하면서 오픈소스를 만든 계기는?',
      answer: `실무에서 Vue.js 전환이 예정되어 있어서 미리 학습하면서 실제 프로젝트를 만들어보고 싶었습니다. Vue.js 공식 문서와 튜토리얼로 기초를 학습하고, 반응형 시스템과 컴포넌트를 이해했는데, 실제 프로젝트로 실습해볼 필요성을 느꼈습니다.

PivotTable.js를 선택한 이유는 실무에서 데이터 분석 도구가 필요했는데, jQuery 버전만 존재하고 Vue 버전이 없었기 때문입니다. 복잡한 상태 관리가 필요해서 Vue 학습에도 적합하다고 생각했습니다.

2019년 8월에 첫 커밋을 하면서 오픈소스 개발을 시작했고, 실무에 적용하면서 지속적으로 개선해나갔습니다. 커뮤니티 피드백을 받으면서 프로젝트가 성장했습니다.

현재까지 GitHub Stars 147개, 주간 다운로드 700건 이상을 기록하고 있으며, 5년간 지속적으로 유지보수하면서 실무 프로젝트에도 다수 적용했습니다.`,
      type: 'business'
    },
    {
      question: '모노레포 구조로 설계한 이유는?',
      answer: `번들 사이즈 최적화와 유지보수성을 위해 pnpm workspace 기반 모노레포를 구성했습니다. 원본 PivotTable.js는 Plotly가 기본으로 포함되어서 번들 크기가 컸는데, 모든 사용자가 차트 렌더러를 필요로 하지는 않았습니다. 다양한 렌더러를 추가할 때마다 의존성 관리가 복잡해지는 문제도 있었습니다.

그래서 packages 폴더 아래에 plotly-renderer와 scroll-renderer 같은 렌더러를 선택적으로 설치할 수 있게 분리하고, 코어 라이브러리는 src 폴더에 두는 모노레포 구조로 설계했습니다.

이렇게 하니까 필요한 렌더러만 선택적으로 설치할 수 있어서 번들 사이즈가 40% 감소했고, 각 패키지의 독립적인 버전 관리가 가능해졌으며, 공통 의존성도 효율적으로 공유할 수 있게 되었습니다.

사용법도 간단해서, 기본은 npm install vue-pivottable만 하면 되고, Plotly가 필요할 때는 npm install @vue-pivottable/plotly-renderer를 추가로 설치하면 됩니다. 각 패키지를 독립적으로 업데이트할 수도 있습니다.`,
      type: 'technical',
      code: `// pnpm-workspace.yaml
packages:
  - 'packages/*'
  - 'docs'

// 선택적 렌더러 사용
import VuePivottable from 'vue-pivottable'
import PlotlyRenderer from '@vue-pivottable/plotly-renderer'

// 필요한 경우만 Plotly 렌더러 추가
Vue.use(PlotlyRenderer)`
    }
  ],

  'vue-datamaps': [
    {
      question: '실무에 어떻게 적용했나요?',
      answer: `Vue Datamaps에 AWS 리전 표시 기능을 직접 추가해서 실무 프로젝트에 적용했습니다. AWS 리전 좌표 데이터를 46개 기본 내장했고, awsRegionsConfig 플러그인을 개발해서 외부 데이터도 제공할 수 있게 했습니다. 리전 코드인 ap-northeast-2를 Seoul 같은 도시명으로 매핑하는 기능과 LayerAwsRegions 컴포넌트도 개발했습니다.

실무에서는 HyperBilling 프로젝트에 적용했는데, 두 가지 메뉴에서 사용했습니다. 다이나믹 서치 메뉴에서는 Bubbles를 사용해서 AWS 리전별 비용을 시각화했습니다. 비용 규모를 버블 크기로 표현하고, Region, Edge, Local, Wavelength 같은 리전 타입별로 색상을 구분했습니다.

데이터 전송 분석 메뉴에서는 Arcs를 활용해서 리전 간 트래픽 흐름을 시각화했습니다. 소스와 타겟 리전을 자동으로 연결하고, 트래픽 양을 선 굵기로 표현했습니다.

기술적으로는 46개 기본 리전을 내장하면서도 외부 데이터로 확장할 수 있게 구성했고, popupTemplate로 리전 정보를 표시하며, fillKey로 활성 리전을 구분하도록 구현했습니다.`,
      type: 'technical'
    }
  ],

  'vue3-pivottable': [
    {
      question: '직장 동료와 팀 프로젝트로 진행한 이유는?',
      answer: `Vue 2로 개발한 개인 프로젝트를 Vue 3로 마이그레이션하는 과정에서 직장 동료들과 함께 진행하게 되었습니다. Vue 2에서 Vue 3로 생태계 전환이 필요했는데, 혼자서는 시간과 리소스에 한계가 있었습니다. 마침 직장 동료들도 Vue 3를 학습하고 싶어해서 함께 하게 되었습니다.

협업은 주간 미팅을 통해 진행했습니다. 매주 진행 상황을 공유하고, 기술적 이슈를 논의하며, 코드 리뷰 세션을 가졌습니다. 역할 분담도 명확하게 했는데, 제가 프로젝트 리드와 핵심 아키텍처 설계를 담당했고, hyemyn2와 gingerbeerlime은 UI 주요 컴포넌트 개발, 기존 Vue2 코드 분석 및 불필요 코드 제거, 리팩토링 및 로직 개선을 맡았습니다.

개발 프로세스는 GitHub PR 기반으로 작업했고, 코드 리뷰를 필수로 했습니다. 기능별 브랜치 전략도 적용했습니다. 결과적으로 TypeScript를 100% 전환했고, 번들 사이즈를 35% 감소시켰으며, Vue 3 Composition API를 적용했습니다. 팀원들의 Vue 3 역량도 많이 향상되었습니다.`,
      type: 'business'
    },
    {
      question: 'Vue 2에서 Vue 3로 마이그레이션하면서 가장 어려웠던 점은?',
      answer: `예상과 달리 기술적 도전보다 GitHub Actions를 통한 자동 배포 프로세스 구축이 가장 어려웠습니다.

기술적으로는 Composition API 전환, 즉 Options API에서 Composition API로 변경하고, 반응성 시스템을 Proxy 기반으로 바꾸며, TypeScript를 도입하고 타입을 정의하는 작업들이 있었습니다. 하지만 이런 부분들은 예상 범위 내였습니다.

정말 어려웠던 것은 GitHub Actions 자동 배포였습니다. 브랜치 보호 규칙과 자동 배포가 충돌했고, 버전 변경 후 main 브랜치에 push할 권한 문제가 있었으며, Personal Access Token 관리도 번거로웠습니다.

배포 프로세스를 설계하면서 여러 시도를 해봤습니다. 처음에는 PAT를 사용했는데 정기적으로 재발급해야 하고 개인에게 의존적이었습니다. 그다음에는 릴리즈 브랜치를 분리해봤지만 커밋 기록이 분화되는 문제가 있었습니다. 최종적으로는 develop → staging → main 플로우를 채택했습니다.

팀 협업 측면에서도 고민이 많았습니다. 팀원 2명에게 동등한 배포 권한을 부여하고, 개인 토큰 의존성을 제거하며, 지속 가능한 관리 체계를 구축해야 했기 때문입니다.`,
      type: 'technical'
    },
    {
      question: 'GitHub Actions 배포 프로세스는 어떻게 구성했나요?',
      answer: `브랜치 보호와 자동 배포의 균형을 맞추기 위해 3단계 브랜치 전략을 채택했습니다.

초기 시도에서는 여러 문제점이 있었습니다. 브랜치 보호 규칙을 적용하면 자동 push가 불가능했고, Personal Access Token 관리 부담이 컸으며, 팀원과 권한을 공유하기도 어려웠습니다.

최종 솔루션으로 develop(개발) → staging(베타) → main(안정)이라는 3단계 브랜치 플로우를 구성했습니다. develop에서는 기능 개발과 버그 수정을 하고, staging에서는 자동 베타 버전 배포를 하며, main에서는 수동 태그로 안정 버전을 배포합니다.

자동화 프로세스도 구축했습니다. develop에서 staging으로, staging에서 main으로 PR을 자동 생성하고, staging에 머지되면 베타 배포가 자동 실행되며, main에 머지 후 태그를 생성하면 정식 배포가 됩니다.

이 방식의 장점은 불필요한 브랜치 생성이 없고, 명확한 버전 관리가 가능하며, 팀원 모두가 동등한 배포 권한을 가지고, PAT 없이도 운영할 수 있다는 것입니다.

Vue 2 버전을 5년간 운영한 경험을 활용해서 유지보수 부담을 최소화하도록 설계했습니다. 버그 수정 외에는 큰 변경이 없을 것으로 예상되기 때문입니다. 관련 문서도 작성해두었는데, 릴리즈 전략은 https://github.com/vue-pivottable/vue3-pivottable/blob/main/docs/RELEASE_STRATEGY.ko.md 에서, Git Flow 전략은 https://github.com/vue-pivottable/vue3-pivottable/blob/main/docs/GIT_FLOW_STRATEGY.md 에서 확인할 수 있습니다.`,
      type: 'business'
    }
  ],

  'code-style': [
    {
      question: 'NaverPayDev/code-style을 참고했다면서 어떤 점이 다른가요?',
      answer: `NaverPayDev/code-style의 모노레포 구조가 인상적이어서 그 방식을 참고해서 만들어봤습니다. pnpm workspace 기반 모노레포와 패키지별 분리 전략, semantic-release 자동 배포 등은 비슷하게 구성했습니다.

다른 부분들도 있는데, 제가 개인적으로 Standard.js를 선호해서 그 규칙을 그대로 따랐습니다. NaverPayDev는 자체 코딩 컨벤션을 정의하시더라고요. 패키지 구성도 좀 달라서, NaverPayDev는 eslint, prettier, stylelint, markdown-lint 등 6개 패키지를 제공하시는데, 저는 eslint-standard-js와 jsx, prettier만 3개로 단순하게 구성했습니다.

사용하는 방식도 조금 다릅니다. ESLint 9의 기본 패턴을 따라서 configs.base를 직접 spread하는 방식으로 만들었고, 설정을 추가하고 싶을 때는 ESLint의 일반적인 방식을 사용하도록 했습니다.

사용자층도 다를 것 같은데, NaverPayDev는 팀 단위 조직에서 쓰실 것 같고, 제 것은 개인이나 소규모 팀에서 Standard.js를 쓰고 싶어하는 분들께 맞을 것 같습니다.`,
      type: 'design'
    },
    {
      question: 'Standard.js를 직접 ESLint 9로 마이그레이션한 이유는?',
      answer: `ESLint 팀이 Flat Config를 새로운 표준으로 설계했는데, Standard.js가 이를 지원하지 않아서 직접 마이그레이션했습니다.

2024년 4월에 출시된 ESLint 9에서 큰 변화가 있었습니다. ESLint 팀이 Flat Config를 기본 설정 방식으로 채택했고, 기존 .eslintrc 방식은 deprecated되었습니다. 물론 ESLINT_USE_FLAT_CONFIG=false로 사용할 수는 있지만, 출시 예정인 ESLint v10에서는 eslintrc가 완전히 제거될 예정입니다.

Standard.js 생태계 현황을 보면 문제가 분명했습니다. 공식 standard/eslint-config-standard는 ESLint 8까지만 지원하고 ESLint 9는 지원하지 않습니다. neostandard는 자체 옵션 시스템을 도입해서 semi를 @stylistic/semi로 매핑하는 등의 방식을 사용합니다. @eslinter/eslint-config-standard는 포크 버전으로 ESLint 9를 지원하지만 비공식입니다.

그래서 직접 구현하기로 결정했습니다. ESLint 9의 표준 설정 패턴을 준수하여 configs 객체를 직접 spread하는 방식을 사용했고, ESLint 규칙명을 그대로 사용해서 추가 추상화가 없도록 했습니다. 다른 ESLint 9 플러그인과 동일한 사용 경험을 제공하면서도 Standard.js 원본 규칙을 100% 유지했습니다.`,
      type: 'technical',
      code: `// neostandard - 자체 옵션 API
neostandard({ semi: true, ts: true })

// 내 프로젝트 - ESLint 9 표준 방식
...standardjs.configs.base`
    },
    {
      question: '실제 활용 사례와 향후 계획은?',
      answer: `현재 Vue3 Pivottable에서 사용 중이며, 개인 프로젝트를 위한 템플릿을 구축하고 있습니다. 실제 사용 사례로는 Vue3 Pivottable 프로젝트에서 ESLint 9 마이그레이션 시에 적용했고, 팀 협업을 위한 일관된 코드 스타일을 확보할 수 있었습니다.

개인 프로젝트용 Vite 템플릿 구축도 진행하고 있습니다. 현재 완료된 것이 5개로, vite-react-ts-standard, vite-react-js-standard, vite-vue3-ts-standard, vite-vue2-ts-standard, vite-vue2-js-standard가 있습니다. 개발 중인 것도 3개 있는데, vite-js-standard, vite-ts-standard, vite-vue3-standard입니다.

핵심 철학은 "특정 규칙을 강요하는 것이 아니라, ESLint와 Prettier 같은 도구를 잘 활용하여 일관성 있는 코드 스타일을 유지하는 것이 중요하다"는 것입니다. Standard.js는 제가 선호하는 규칙일 뿐이고, 팀이나 개발 환경에 맞는 규칙을 선택하는 것이 중요합니다. 일관성 있는 코드 스타일이 핵심입니다.

향후 목표로는 개인 개발 시 템플릿 활용으로 생산성을 향상시키고, 향후 팀 프로젝트에서도 유사한 템플릿 방식 적용을 검토할 계획입니다. 각 팀의 코딩 컨벤션에 맞는 템플릿을 구축하는 경험도 축적해나갈 예정입니다.`,
      type: 'business',
      code: `# 개인 프로젝트 시작 시
git clone https://github.com/Seungwoo321/vite-react-ts-standard
pnpm install && pnpm dev`
    }
  ]
};

export const getProjectQA = (projectId: string): ProjectQA[] => {
  return projectQAs[projectId] || [];
};